extern crate clap;
// use std::{process, env};
// use std::error::Error;
// use std::fs::File;
// use std::io::prelude::*;

#[macro_use]
mod args;

#[macro_use]
mod process;

// use args;

fn main() {
  let help: clap::App<'a, 'a> = args::prepare()
  let matches = help.get_matches();
  
  match matches.subcommand_name() {
    Some("add") => process::add("a"),
    Some("search") => process::add("ab"),
    _           => args::prepare().print_help(),
    None        => process::lwd(),
  }

  // let mut args: Vec<String> = env::args().collect();
  // if args.len() < 3 {
  //   println!("Usage _lwd_complete $PWD [search] [limit]");
  //   process::exit(1);
  // }
  // args.remove(0); // shift args


  // let mut dirs = vec![];
  
  // let path = env::home_dir().unwrap().as_path().join(".lwd");
  // let display = path.display();
  // let mut file = match File::open(&path) {
  //   // The `description` method of `io::Error` returns a string that
  //   // describes the error
  //   Err(why) => panic!("couldn't open {}: {}", display,
  //                                               why.description()),
  //   Ok(file) => file,
  // };

  // println!("{}", args[1]);
  // let mut s = String::new();
  // match file.read_to_string(&mut s) {
  //   Err(why) => panic!("couldn't read {}: {}", display, why.description()),
  //   Ok(_) => {
  //     match arg {
  //         Some(expr) => expr,
  //         None => expr,
  //     }
  //     dirs.push(s)
  //   }
  // }
  // println!("{:?}", dirs);
}
